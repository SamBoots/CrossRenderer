#include "DX12Backend.h"
#include "DX12Common.h"
#include "D3D12MemAlloc.h"

#include "DXC/inc/dxcapi.h"
#include "DXC/inc/d3d12shader.h"

#include "Slotmap.h"
#include "BBString.h"

//Tutorial used for this DX12 backend was https://alain.xyz/blog/raw-directx12 

using namespace BB;

static FreelistAllocator_t s_DX12Allocator{ mbSize * 2 };

struct DXMAResource
{
	D3D12MA::Allocation* allocation;
	ID3D12Resource* resource;
	DX12BufferView view;
};

struct ShaderCompiler
{
	IDxcUtils* utils;
	IDxcCompiler3* compiler;
	IDxcLibrary* library;
};

struct DX12Backend_inst
{
	UINT currentFrame = 0;
	UINT backBufferCount = 3; //for now hardcode 3 backbuffers.

	IDXGIFactory4* factory{};
	ID3D12Debug1* debugController{};

	ID3D12CommandQueue* directQueue{};
	ID3D12CommandAllocator* commandAllocator{};

	UINT64 fenceValue = 0;
	HANDLE fenceEvent{};
	ID3D12Fence* fence{};

	DX12Device device{};
	DX12Swapchain swapchain{};

	D3D12MA::Allocator* DXMA;

	Slotmap<DXMAResource> renderResources{ s_DX12Allocator };
	Slotmap<ID3D12PipelineState*> pipelines{ s_DX12Allocator };
	Slotmap<ID3D12GraphicsCommandList*> commandLists{ s_DX12Allocator };

	ShaderCompiler shaderCompiler;
};
static DX12Backend_inst s_DX12BackendInst;

static void SetupShaderCompiler()
{
	DXASSERT(DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&s_DX12BackendInst.shaderCompiler.utils)), 
		"DX12: Failed to create Shader Compile Instance");
	DXASSERT(DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&s_DX12BackendInst.shaderCompiler.compiler)),
		"DX12: Failed to create Shader Compile Compiler");
	DXASSERT(DxcCreateInstance(CLSID_DxcLibrary, IID_PPV_ARGS(& s_DX12BackendInst.shaderCompiler.library)),
		"DX12: Failed to create Shader Compile include_header");
}

enum class ShaderType
{
	VERTEX,
	PIXEL
};

static IDxcBlob* CompileShader(Allocator a_TempAllocator, const wchar_t* a_FullPath, ShaderType a_Type)
{
	LPCWSTR shaderType;
	switch (a_Type)
	{
	case ShaderType::VERTEX:
		shaderType = L"vs_6_0";
		break;
	case ShaderType::PIXEL:
		shaderType = L"ps_6_0";
		break;
	}

	LPCWSTR pszArgs[] =
	{
		a_FullPath,					 // Optional shader source file name for error reporting
									 // and for PIX shader source view.  
		L"-E", L"main",              // Entry point.
		L"-T", shaderType,            // Target.
		L"-Zs",                      // Enable debug information (slim format)
	//	L"-D", L"MYDEFINE=1",        // A single define.
	//	L"-Fo", L"myshader.bin",     // Optional. Stored in the pdb. 
	//	L"-Fd", L"myshader.pdb",     // The file name of the pdb. This must either be supplied
									 // or the autogenerated file name must be used.
	//	L"-Qstrip_reflect",          // Strip reflection into a separate blob. 
	};

	IDxcBlobEncoding* t_SourceBlob;
	DXASSERT(s_DX12BackendInst.shaderCompiler.utils->LoadFile(a_FullPath, nullptr, &t_SourceBlob),
		"DX12: Failed to load file before compiling it.");
	DxcBuffer t_Source;
	t_Source.Ptr = t_SourceBlob->GetBufferPointer();
	t_Source.Size = t_SourceBlob->GetBufferSize();
	t_Source.Encoding = DXC_CP_ACP;

	IDxcResult* t_Result;
	HRESULT t_HR;

	t_HR = s_DX12BackendInst.shaderCompiler.compiler->Compile(
		&t_Source,
		pszArgs,
		_countof(pszArgs),
		nullptr,
		IID_PPV_ARGS(&t_Result)
	);

	IDxcBlobUtf8* t_Errors = nullptr;
	t_Result->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&t_Errors), nullptr);

	if (t_Errors != nullptr)
	{
		wprintf(L"Shader Compilation failed with errors:\n%hs\n",
			(const char*)t_Errors->GetStringPointer());
		t_Errors->Release();
	}
	
	t_Result->GetStatus(&t_HR);
	if (FAILED(t_HR))
	{
		BB_ASSERT(false, "DX12: Failed to load shader.");
	}

	IDxcBlob* t_ShaderCode;
	t_Result->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&t_ShaderCode), nullptr);
	if (t_ShaderCode->GetBufferPointer() == nullptr)
	{
		BB_ASSERT(false, "DX12: Something went wrong with DXC shader compiling.");
	}

	t_SourceBlob->Release();
	t_Result->Release();

	return t_ShaderCode;
}

static ID3D12RootSignature* CreateRootSignature()
{
	ID3D12RootSignature* t_RootSignature = nullptr;

	D3D12_FEATURE_DATA_ROOT_SIGNATURE t_FeatureData = {};
	t_FeatureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_1;

	if (FAILED(s_DX12BackendInst.device.logicalDevice->CheckFeatureSupport(
		D3D12_FEATURE_ROOT_SIGNATURE,
		&t_FeatureData, sizeof(t_FeatureData))))
	{
		t_FeatureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_0;
	}

	//Individual GPU Resources
	D3D12_DESCRIPTOR_RANGE1 t_Ranges[1];
	t_Ranges[0].BaseShaderRegister = 0;
	t_Ranges[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_CBV;
	t_Ranges[0].NumDescriptors = 1;
	t_Ranges[0].RegisterSpace = 0;
	t_Ranges[0].OffsetInDescriptorsFromTableStart = 0;
	t_Ranges[0].Flags = D3D12_DESCRIPTOR_RANGE_FLAG_NONE;

	//Groups of GPU Resources
	D3D12_ROOT_PARAMETER1 t_RootParameters[1];
	t_RootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
	t_RootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;

	t_RootParameters[0].DescriptorTable.NumDescriptorRanges = 1;
	t_RootParameters[0].DescriptorTable.pDescriptorRanges = t_Ranges;

	//Overall Layout
	D3D12_VERSIONED_ROOT_SIGNATURE_DESC t_RootSignatureDesc;
	t_RootSignatureDesc.Version = D3D_ROOT_SIGNATURE_VERSION_1_1;
	t_RootSignatureDesc.Desc_1_1.Flags =
		D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	t_RootSignatureDesc.Desc_1_1.NumParameters = 1;
	t_RootSignatureDesc.Desc_1_1.pParameters = t_RootParameters;
	t_RootSignatureDesc.Desc_1_1.NumStaticSamplers = 0;
	t_RootSignatureDesc.Desc_1_1.pStaticSamplers = nullptr;

	ID3DBlob* t_Signature;
	ID3DBlob* t_Error;

	DXASSERT(D3D12SerializeVersionedRootSignature(&t_RootSignatureDesc,
		&t_Signature, &t_Error),
		"DX12: Failed to serialize root signature.");

	DXASSERT(s_DX12BackendInst.device.logicalDevice->CreateRootSignature(0,
		t_Signature->GetBufferPointer(),
		t_Signature->GetBufferSize(),
		IID_PPV_ARGS(&t_RootSignature)),
		"DX12: Failed to create root signature.");

	t_RootSignature->SetName(L"Hello Triangle Root Signature");

	if (t_Error != nullptr)
	{
		BB_LOG((const char*)t_Error->GetBufferPointer());
		BB_ASSERT(false, "DX12: error creating root signature, details are above.");
		t_Error->Release();
	}

	if (t_Signature != nullptr)
		t_Signature->Release();

	return t_RootSignature;
}

static void SetupBackendSwapChain(UINT a_Width, UINT a_Height, HWND a_WindowHandle)
{
	s_DX12BackendInst.swapchain.width = a_Width;
	s_DX12BackendInst.swapchain.height = a_Height;

	//Just do a resize if a swapchain already exists.
	if (s_DX12BackendInst.swapchain.swapchain != nullptr)
	{
		s_DX12BackendInst.swapchain.swapchain->ResizeBuffers(s_DX12BackendInst.backBufferCount,
			a_Width,
			a_Height,
			DXGI_FORMAT_R8G8B8A8_UNORM,
			0);
		return;
	}

	D3D12_VIEWPORT t_Viewport;
	D3D12_RECT t_SurfaceRect;

	t_Viewport.TopLeftX = 0.0f;
	t_Viewport.TopLeftY = 0.0f;
	t_Viewport.Width = static_cast<float>(a_Width);
	t_Viewport.Height = static_cast<float>(a_Height);
	t_Viewport.MinDepth = .1f;
	t_Viewport.MaxDepth = 1000.f;

	t_SurfaceRect.left = 0;
	t_SurfaceRect.top = 0;
	t_SurfaceRect.right = static_cast<LONG>(a_Width);
	t_SurfaceRect.bottom = static_cast<LONG>(a_Height);

	s_DX12BackendInst.swapchain.viewport = t_Viewport;
	s_DX12BackendInst.swapchain.surfaceRect = t_SurfaceRect;

	DXGI_SWAP_CHAIN_DESC1 t_SwapchainDesc = {};
	t_SwapchainDesc.BufferCount = s_DX12BackendInst.backBufferCount;
	t_SwapchainDesc.Width = a_Width;
	t_SwapchainDesc.Height = a_Height;
	t_SwapchainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	t_SwapchainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
	t_SwapchainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;
	t_SwapchainDesc.SampleDesc.Count = 1;

	IDXGISwapChain1* t_NewSwapchain;
	DXASSERT(s_DX12BackendInst.factory->CreateSwapChainForHwnd(
		s_DX12BackendInst.directQueue,
		a_WindowHandle,
		&t_SwapchainDesc,
		nullptr,
		nullptr,
		&t_NewSwapchain), 
		"DX12: Failed to create swapchain1");

	DXASSERT(s_DX12BackendInst.factory->MakeWindowAssociation(a_WindowHandle,
		DXGI_MWA_NO_ALT_ENTER),
		"DX12: Failed to add DXGI_MWA_NO_ALT_ENTER to window.");

	DXASSERT(t_NewSwapchain->QueryInterface(
		__uuidof(IDXGISwapChain3), (void**)&t_NewSwapchain),
		"DX12: Failed to get support for a IDXGISwapchain3.");

	s_DX12BackendInst.swapchain.swapchain = (IDXGISwapChain3*)t_NewSwapchain;

	s_DX12BackendInst.currentFrame = s_DX12BackendInst.swapchain.swapchain->GetCurrentBackBufferIndex();

	D3D12_DESCRIPTOR_HEAP_DESC t_RtvHeapDesc = {};
	t_RtvHeapDesc.NumDescriptors = s_DX12BackendInst.backBufferCount;
	t_RtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
	t_RtvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	DXASSERT(s_DX12BackendInst.device.logicalDevice->CreateDescriptorHeap(
		&t_RtvHeapDesc, IID_PPV_ARGS(&s_DX12BackendInst.swapchain.rtvHeap)),
		"DX12: Failed to create descriptor heap for swapchain.");


	s_DX12BackendInst.swapchain.rtvDescriptorSize =
		s_DX12BackendInst.device.logicalDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

	D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = 
		s_DX12BackendInst.swapchain.rtvHeap->GetCPUDescriptorHandleForHeapStart();

	s_DX12BackendInst.swapchain.renderTargets = BBnewArr(s_DX12Allocator, s_DX12BackendInst.backBufferCount, ID3D12Resource*);

	// Create a RTV for each frame.
	for (UINT i = 0; i < s_DX12BackendInst.backBufferCount; i++)
	{
		DXASSERT(s_DX12BackendInst.swapchain.swapchain->GetBuffer(i,
			IID_PPV_ARGS(&s_DX12BackendInst.swapchain.renderTargets[i])),
			"DX12: Failed to get swapchain buffer.");

		s_DX12BackendInst.device.logicalDevice->CreateRenderTargetView(
			s_DX12BackendInst.swapchain.renderTargets[i], 
			nullptr, 
			rtvHandle);
		rtvHandle.ptr += (1 * s_DX12BackendInst.swapchain.rtvDescriptorSize);
	}
}


APIRenderBackend BB::DX12CreateBackend(Allocator a_TempAllocator, const RenderBackendCreateInfo& a_CreateInfo)
{
	UINT t_FactoryFlags = 0;

	if (a_CreateInfo.validationLayers)
	{
		ID3D12Debug* t_DebugController;
		DXASSERT(D3D12GetDebugInterface(IID_PPV_ARGS(&t_DebugController)),
			"DX12: failed to create debuginterface.");
		DXASSERT(t_DebugController->QueryInterface(IID_PPV_ARGS(&s_DX12BackendInst.debugController)),
			"DX12: failed to create debuginterface.");
		s_DX12BackendInst.debugController->EnableDebugLayer();
		s_DX12BackendInst.debugController->SetEnableGPUBasedValidation(true);

		t_FactoryFlags |= DXGI_CREATE_FACTORY_DEBUG;

		t_DebugController->Release();
	}
	else
	{
		s_DX12BackendInst.debugController = nullptr;
	}

	DXASSERT(CreateDXGIFactory2(t_FactoryFlags, IID_PPV_ARGS(&s_DX12BackendInst.factory)),
		"DX12: failed to create DXGIFactory2.");

#pragma region DEVICE_CREATION
	IDXGIAdapter1* t_CurrentBestAdapter = nullptr;
	SIZE_T t_BestDedicatedVRAM = 0;

	for (UINT adapterIndex = 0;
		DXGI_ERROR_NOT_FOUND != s_DX12BackendInst.factory->EnumAdapters1(adapterIndex, &s_DX12BackendInst.device.adapter);
		++adapterIndex)
	{
		DXGI_ADAPTER_DESC1 t_Desc;
		s_DX12BackendInst.device.adapter->GetDesc1(&t_Desc);

		//We don't take the software adapter.
		if (t_Desc.Flags & DXGI_ADAPTER_FLAG_SOFTWARE)
			continue;

		if (t_Desc.DedicatedVideoMemory > t_BestDedicatedVRAM)
		{
			t_BestDedicatedVRAM = t_Desc.DedicatedVideoMemory;
			t_CurrentBestAdapter = s_DX12BackendInst.device.adapter;
		}
	}
	s_DX12BackendInst.device.adapter = t_CurrentBestAdapter;

	DXASSERT(D3D12CreateDevice(s_DX12BackendInst.device.adapter,
		D3D_FEATURE_LEVEL_12_0,
		IID_PPV_ARGS(&s_DX12BackendInst.device.logicalDevice)),
		"DX12: Failed to create logical device.");

	if (a_CreateInfo.validationLayers)
	{
		DXASSERT(s_DX12BackendInst.device.logicalDevice->QueryInterface(&s_DX12BackendInst.device.debugDevice),
			"DX12: Failed to query debug device.");
	}
	else
	{
		s_DX12BackendInst.device.debugDevice = nullptr;
	}
#pragma endregion //DEVICE_CREATION

	D3D12MA::ALLOCATOR_DESC t_AllocatorDesc = {};
	t_AllocatorDesc.pDevice = s_DX12BackendInst.device.logicalDevice;
	t_AllocatorDesc.pAdapter = s_DX12BackendInst.device.adapter;

	DXASSERT(D3D12MA::CreateAllocator(&t_AllocatorDesc, &s_DX12BackendInst.DXMA),
		"DX12: Failed to create DX12 memory allocator");

	D3D12_COMMAND_QUEUE_DESC t_QueueDesc{};
	t_QueueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
	t_QueueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
	DXASSERT(s_DX12BackendInst.device.logicalDevice->CreateCommandQueue(&t_QueueDesc,
		IID_PPV_ARGS(&s_DX12BackendInst.directQueue)),
		"DX12: Failed to create direct command queue");

	DXASSERT(s_DX12BackendInst.device.logicalDevice->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT,
		IID_PPV_ARGS(&s_DX12BackendInst.commandAllocator)),
		"DX12: Failed to create command allocator");
	 
	DXASSERT(s_DX12BackendInst.device.logicalDevice->CreateFence(0, D3D12_FENCE_FLAG_NONE,
		IID_PPV_ARGS(&s_DX12BackendInst.fence)),
		"DX12: Failed to create fence");

	SetupBackendSwapChain(a_CreateInfo.windowWidth, a_CreateInfo.windowHeight, a_CreateInfo.hwnd);

	//Create the shader compiler.
	SetupShaderCompiler();

	//The handle doesn't matter, we only have one backend anyway. But it's nice for API clarity.
	return APIRenderBackend(1);
}

PipelineHandle BB::DX12CreatePipeline(Allocator a_TempAllocator, const RenderPipelineCreateInfo& a_CreateInfo)
{
	ID3D12PipelineState* t_PipelineState;

	D3D12_GRAPHICS_PIPELINE_STATE_DESC t_PsoDesc = {};

	D3D12_INPUT_ELEMENT_DESC t_InputElementDescs[] = {
		{"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0,
		D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0},
		{"COLOR", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 12,
		D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0} };

	t_PsoDesc.InputLayout = { t_InputElementDescs, _countof(t_InputElementDescs) };

	t_PsoDesc.pRootSignature = CreateRootSignature();
	IDxcBlob* t_ShaderCode[2]; // 0 vertex, 1 frag.
	t_ShaderCode[0] = CompileShader(a_TempAllocator, a_CreateInfo.shaderPaths[0], ShaderType::VERTEX);
	t_ShaderCode[1] = CompileShader(a_TempAllocator, a_CreateInfo.shaderPaths[1], ShaderType::PIXEL);

	//All the vertex shader stuff
	D3D12_SHADER_BYTECODE t_VertexShader;
	t_VertexShader.BytecodeLength = t_ShaderCode[0]->GetBufferSize();
	t_VertexShader.pShaderBytecode = t_ShaderCode[0]->GetBufferPointer();
	t_PsoDesc.VS = t_VertexShader;

	//All the pixel shader stuff
	D3D12_SHADER_BYTECODE t_PixelShader;
	t_PixelShader.BytecodeLength = t_ShaderCode[1]->GetBufferSize();
	t_PixelShader.pShaderBytecode = t_ShaderCode[1]->GetBufferPointer();
	t_PsoDesc.PS = t_PixelShader;

	D3D12_RASTERIZER_DESC t_RasterDesc;
	t_RasterDesc.FillMode = D3D12_FILL_MODE_SOLID;
	t_RasterDesc.CullMode = D3D12_CULL_MODE_NONE;
	t_RasterDesc.FrontCounterClockwise = FALSE;
	t_RasterDesc.DepthBias = D3D12_DEFAULT_DEPTH_BIAS;
	t_RasterDesc.DepthBiasClamp = D3D12_DEFAULT_DEPTH_BIAS_CLAMP;
	t_RasterDesc.SlopeScaledDepthBias = D3D12_DEFAULT_SLOPE_SCALED_DEPTH_BIAS;
	t_RasterDesc.DepthClipEnable = TRUE;
	t_RasterDesc.MultisampleEnable = FALSE;
	t_RasterDesc.AntialiasedLineEnable = FALSE;
	t_RasterDesc.ForcedSampleCount = 0;
	t_RasterDesc.ConservativeRaster = D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF;
	t_PsoDesc.RasterizerState = t_RasterDesc;
	t_PsoDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	D3D12_BLEND_DESC t_BlendDesc;
	t_BlendDesc.AlphaToCoverageEnable = FALSE;
	t_BlendDesc.IndependentBlendEnable = FALSE;
	const D3D12_RENDER_TARGET_BLEND_DESC defaultRenderTargetBlendDesc = {
		FALSE,
		FALSE,
		D3D12_BLEND_ONE,
		D3D12_BLEND_ZERO,
		D3D12_BLEND_OP_ADD,
		D3D12_BLEND_ONE,
		D3D12_BLEND_ZERO,
		D3D12_BLEND_OP_ADD,
		D3D12_LOGIC_OP_NOOP,
		D3D12_COLOR_WRITE_ENABLE_ALL,
	};
	for (UINT i = 0; i < D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT; ++i)
		t_BlendDesc.RenderTarget[i] = defaultRenderTargetBlendDesc;
	t_PsoDesc.BlendState = t_BlendDesc;

	t_PsoDesc.DepthStencilState.DepthEnable = FALSE;
	t_PsoDesc.DepthStencilState.StencilEnable = FALSE;
	t_PsoDesc.SampleMask = UINT_MAX;

	t_PsoDesc.NumRenderTargets = 1;
	t_PsoDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
	t_PsoDesc.SampleDesc.Count = 1;

	DXASSERT(s_DX12BackendInst.device.logicalDevice->CreateGraphicsPipelineState(
		&t_PsoDesc, IID_PPV_ARGS(&t_PipelineState)),
		"DX12: Failed to create graphics pipeline");

	return PipelineHandle(s_DX12BackendInst.pipelines.emplace(t_PipelineState));
}

CommandListHandle BB::DX12CreateCommandList(Allocator a_TempAllocator, const uint32_t a_BufferCount)
{
	ID3D12GraphicsCommandList* a_CommandList;

	DXASSERT(s_DX12BackendInst.device.logicalDevice->CreateCommandList(
		0,
		D3D12_COMMAND_LIST_TYPE_DIRECT,
		s_DX12BackendInst.commandAllocator,
		s_DX12BackendInst.pipelines.find(0),
		IID_PPV_ARGS(&a_CommandList)),
		"DX12: Failed to create commandlist");

	//Close it for now
	a_CommandList->Close();


	return CommandListHandle(s_DX12BackendInst.commandLists.insert(a_CommandList));
}

RBufferHandle BB::DX12CreateBuffer(const RenderBufferCreateInfo& a_Info)
{
	DXMAResource t_Resource;

	D3D12_RESOURCE_DESC t_ResourceDesc = {};
	t_ResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	t_ResourceDesc.Alignment = 0;
	t_ResourceDesc.Width = a_Info.size;
	t_ResourceDesc.Height = 1;
	t_ResourceDesc.DepthOrArraySize = 1;
	t_ResourceDesc.MipLevels = 1;
	t_ResourceDesc.Format = DXGI_FORMAT_UNKNOWN;
	t_ResourceDesc.SampleDesc.Count = 1;
	t_ResourceDesc.SampleDesc.Quality = 0;
	t_ResourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
	t_ResourceDesc.Flags = D3D12_RESOURCE_FLAG_NONE;

	D3D12MA::ALLOCATION_DESC t_AllocationDesc = {};
	t_AllocationDesc.HeapType = D3D12_HEAP_TYPE_UPLOAD;

	DXASSERT(s_DX12BackendInst.DXMA->CreateResource(
		&t_AllocationDesc,
		&t_ResourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		NULL,
		&t_Resource.allocation,
		IID_PPV_ARGS(&t_Resource.resource)),
		"DX12: Failed to create resource using D3D12 Memory Allocator");

	switch (a_Info.usage)
	{
	case RENDER_BUFFER_USAGE::VERTEX:
		t_Resource.view.vertexView.BufferLocation = t_Resource.resource->GetGPUVirtualAddress();
		t_Resource.view.vertexView.StrideInBytes = sizeof(Vertex);
		t_Resource.view.vertexView.SizeInBytes = a_Info.size;
		break;
	case RENDER_BUFFER_USAGE::INDEX:
		t_Resource.view.indexView.BufferLocation = t_Resource.resource->GetGPUVirtualAddress();
		t_Resource.view.indexView.Format = DXGI_FORMAT_R32_UINT;
		t_Resource.view.indexView.SizeInBytes = a_Info.size;
		break;
	case RENDER_BUFFER_USAGE::UNIFORM:
		BB_ASSERT(false, "this buffer usage is not supported by the DirectX12 backend!");
		break;
	default:
		BB_ASSERT(false, "this buffer usage is not supported by the DirectX12 backend!");
		break;
	}

	if (a_Info.data != nullptr)
	{
		void* t_MappedPtr;
		D3D12_RANGE t_ReadRange;
		t_ReadRange.Begin = 0;
		t_ReadRange.End = 0;

		DXASSERT(t_Resource.resource->Map(0, nullptr, &t_MappedPtr),
			"DX12: failed to map memory to resource.");
		memcpy(t_MappedPtr, a_Info.data, a_Info.size);
		t_Resource.resource->Unmap(0, nullptr);
	}

	return RBufferHandle(s_DX12BackendInst.renderResources.insert(t_Resource));
}

void BB::DX12BufferCopyData(RBufferHandle a_Handle, const void* a_Data, RDeviceBufferView a_View)
{
	DXMAResource& t_Resource = s_DX12BackendInst.renderResources.find(a_Handle.handle);
	void* t_MapPtr;

	DXASSERT(t_Resource.resource->Map(0, NULL, &t_MapPtr),
		"DX12: Failed to map resource.");

	memcpy(t_MapPtr, a_Data, a_View.size);

	t_Resource.resource->Unmap(0, NULL);
}

void BB::DX12RenderFrame(Allocator a_TempAllocator, CommandListHandle a_CommandHandle, FrameBufferHandle a_FrameBufferHandle, PipelineHandle a_PipeHandle)
{
	DXASSERT(s_DX12BackendInst.commandAllocator->Reset(), "DX12: Failed to reset allocator.");

	ID3D12GraphicsCommandList* t_CommandList = s_DX12BackendInst.commandLists.find(a_CommandHandle.handle);
	DXASSERT(t_CommandList->Reset(s_DX12BackendInst.commandAllocator,
		s_DX12BackendInst.pipelines.find(a_PipeHandle.handle)),
		"DX12: Failed to reset commandlist.");

	t_CommandList->SetGraphicsRootSignature(CreateRootSignature());

	D3D12_RESOURCE_BARRIER renderTargetBarrier;
	renderTargetBarrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	renderTargetBarrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
	renderTargetBarrier.Transition.pResource = s_DX12BackendInst.swapchain.renderTargets[s_DX12BackendInst.currentFrame];
	renderTargetBarrier.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
	renderTargetBarrier.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;
	renderTargetBarrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
	t_CommandList->ResourceBarrier(1, &renderTargetBarrier);

	D3D12_CPU_DESCRIPTOR_HANDLE
		rtvHandle(s_DX12BackendInst.swapchain.rtvHeap->GetCPUDescriptorHandleForHeapStart());
	rtvHandle.ptr = rtvHandle.ptr + (s_DX12BackendInst.currentFrame * s_DX12BackendInst.swapchain.rtvDescriptorSize);
	t_CommandList->OMSetRenderTargets(1, &rtvHandle, FALSE, nullptr);

	const float clearColor[] = { 0.2f, 0.2f, 0.2f, 1.0f };
	t_CommandList->RSSetViewports(1, &s_DX12BackendInst.swapchain.viewport);
	t_CommandList->RSSetScissorRects(1, &s_DX12BackendInst.swapchain.surfaceRect);
	t_CommandList->ClearRenderTargetView(rtvHandle, clearColor, 0, nullptr);
	t_CommandList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	t_CommandList->IASetVertexBuffers(0, 1, &s_DX12BackendInst.renderResources.find(0).view.vertexView);

	t_CommandList->DrawInstanced(3, 1, 0, 0);


	// Indicate that the back buffer will now be used to present.
	D3D12_RESOURCE_BARRIER presentBarrier;
	presentBarrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	presentBarrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
	presentBarrier.Transition.pResource = s_DX12BackendInst.swapchain.renderTargets[s_DX12BackendInst.currentFrame];
	presentBarrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
	presentBarrier.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;
	presentBarrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

	t_CommandList->ResourceBarrier(1, &presentBarrier);

	DXASSERT(t_CommandList->Close(), "DX12: Failed to close commandlist.");

	ID3D12CommandList* t_CommandListSend[] = { t_CommandList };
	s_DX12BackendInst.directQueue->ExecuteCommandLists(1, t_CommandListSend);

	s_DX12BackendInst.swapchain.swapchain->Present(1, 0);

	const UINT64 fenceV = s_DX12BackendInst.fenceValue;
	s_DX12BackendInst.directQueue->Signal(s_DX12BackendInst.fence, fenceV);
	++s_DX12BackendInst.fenceValue;

	if (s_DX12BackendInst.fence->GetCompletedValue() < fenceV)
	{
		DXASSERT(s_DX12BackendInst.fence->SetEventOnCompletion(fenceV, s_DX12BackendInst.fenceEvent),
			"DX12: Failed to wait for event complection on fence.");
		WaitForSingleObject(s_DX12BackendInst.fenceEvent, INFINITE);
	}

	s_DX12BackendInst.currentFrame = s_DX12BackendInst.swapchain.swapchain->GetCurrentBackBufferIndex();
}

void BB::DX12DestroyBuffer(RBufferHandle a_Handle)
{
	DXMAResource& t_Resource = s_DX12BackendInst.renderResources.find(a_Handle.handle);
	t_Resource.resource->Release();
	t_Resource.allocation->Release();
	s_DX12BackendInst.renderResources.erase(a_Handle.handle);


}

void BB::DX12DestroyCommandList(CommandListHandle a_Handle)
{
	s_DX12BackendInst.commandLists.find(a_Handle.handle)->Release();
	s_DX12BackendInst.commandLists.erase(a_Handle.handle);
}

void BB::DX12DestroyPipeline(PipelineHandle a_Handle)
{
	s_DX12BackendInst.pipelines.find(a_Handle.handle)->Release();
	s_DX12BackendInst.pipelines.erase(a_Handle.handle);
}

void BB::DX12DestroyBackend(APIRenderBackend)
{
	for (size_t i = 0; i < s_DX12BackendInst.backBufferCount; i++)
	{
		s_DX12BackendInst.swapchain.renderTargets[i]->Release();
	}
	BBfreeArr(s_DX12Allocator, s_DX12BackendInst.swapchain.renderTargets);
	s_DX12BackendInst.swapchain.rtvHeap->Release();
	s_DX12BackendInst.swapchain.swapchain->Release();

	s_DX12BackendInst.commandAllocator->Release();
	s_DX12BackendInst.directQueue->Release();
	s_DX12BackendInst.fence->Release();

	s_DX12BackendInst.DXMA->Release();
	if (s_DX12BackendInst.device.debugDevice)
		s_DX12BackendInst.device.debugDevice->Release();
	s_DX12BackendInst.device.logicalDevice->Release();
	s_DX12BackendInst.device.adapter->Release();
	if (s_DX12BackendInst.debugController)
		s_DX12BackendInst.debugController->Release();
	s_DX12BackendInst.factory->Release();
}